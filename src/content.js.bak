// PDF Scanner Extension - Content Script
// This runs in the context of AI chat websites to monitor for PDF uploads

// Create a logger for the content script
const logger = {
  log(message, data) {
    try {
      if (data !== undefined) {
        console.log(`[PDF Scanner] ${message}`, data);
      } else {
        console.log(`[PDF Scanner] ${message}`);
      }
    } catch (e) {
      // Silent fail if console is not available
    }
  },
  
  warn(message, data) {
    try {
      if (data !== undefined) {
        console.warn(`[PDF Scanner] WARNING: ${message}`, data);
      } else {
        console.warn(`[PDF Scanner] WARNING: ${message}`);
      }
    } catch (e) {
      // Silent fail if console is not available
    }
  },
  
  error(message, data) {
    try {
      if (data !== undefined) {
        console.error(`[PDF Scanner] ERROR: ${message}`, data);
      } else {
        console.error(`[PDF Scanner] ERROR: ${message}`);
      }
    } catch (e) {
      // Silent fail if console is not available
    }
  }
};

// Log that content script has loaded
logger.log(`Content script loaded on ${window.location.href}`);
console.log('[PDF Scanner] Content script loaded');

/**
 * Class to monitor the page for PDF file uploads and coordinate with service worker
 */
class PDFMonitor {
  constructor() {
    this.fileInputs = new Set();
    this.uploadState = {
      monitoring: true,
      pendingScans: new Map(),
      activeUploads: new Set()
    };
    
    // Debug mode
    this.debugMode = true;
    
    logger.log('PDF Monitor initializing');
    this.init();
  }
  
  /**
   * Initialize the monitor
   */
  init() {
    try {
      logger.log('Initializing PDF Monitor');
      
      // Set up message listener first
      chrome.runtime.onMessage.addListener(this.handleMessage.bind(this));
      logger.log('Message listener set up');
      
      // Start monitoring for file inputs
      this.startMonitoring();
      
      // Notify background that content script is active
      this.sendMessage({
        type: 'content_loaded',
        url: window.location.href
      }).then(() => {
        logger.log('Sent content_loaded message to background');
      }).catch(err => {
        logger.error('Error sending content_loaded message', { error: err.message });
      });
      
      logger.log('PDF Monitor initialized');
      
      // Monitor for drag and drop events
      this.setupDragAndDropMonitoring();
      
      // Monitor for clipboard paste events
      this.setupClipboardMonitoring();
      
      // Monitor for file selection dialog
      this.monitorFileSelectionDialog();
    } catch (error) {
      logger.error('Error initializing PDF Monitor', { error: error.message });
    }
  }
  
  /**
   * Start monitoring the page for file inputs
   */
  startMonitoring() {
    try {
      // Initial scan for existing file inputs
      this.scanForFileInputs();
      
      // Set up mutation observer to detect dynamically added file inputs
      this.observer = new MutationObserver(mutations => {
        let shouldRescan = false;
        
        for (const mutation of mutations) {
          if (mutation.type === 'childList' && mutation.addedNodes.length) {
            shouldRescan = true;
            break;
          }
        }
        
        if (shouldRescan) {
          this.scanForFileInputs();
          
          // Also check for ChatGPT-specific elements
          this.checkForChatGPTFileElements();
        }
      });
      
      // Start observing
      this.observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      
      // Monitor form submissions
      this.setupFormSubmissionMonitoring();
      
      // Check for ChatGPT-specific elements
      this.checkForChatGPTFileElements();
      
      logger.log('Started monitoring for file inputs');
    } catch (error) {
      logger.error('Error starting monitoring', { error: error.message });
    }
  }
  
  /**
   * Check for ChatGPT-specific file upload elements
   */
  checkForChatGPTFileElements() {
    try {
      // ChatGPT has a specific file upload button
      const fileButtons = document.querySelectorAll('button[aria-label*="upload"], button[aria-label*="attach"], button[aria-label*="file"]');
      
      fileButtons.forEach(button => {
        if (!button._pdfScannerMonitored) {
          button._pdfScannerMonitored = true;
          button.addEventListener('click', () => {
            logger.log('ChatGPT file upload button clicked');
            // The actual file input will be detected by our other monitoring
          });
        }
      });
      
      // Look for file attachments already in the UI
      const attachmentElements = document.querySelectorAll('[data-testid*="attachment"], [class*="attachment"], [class*="file-attachment"]');
      
      attachmentElements.forEach(element => {
        if (!element._pdfScannerMonitored) {
          element._pdfScannerMonitored = true;
          
          // Check if this looks like a PDF
          const isPDF = 
            element.textContent?.toLowerCase().includes('.pdf') ||
            element.getAttribute('aria-label')?.toLowerCase().includes('pdf') ||
            element.querySelector('img[alt*="PDF" i]');
          
          if (isPDF) {
            logger.log('Found PDF attachment in UI', {
              text: element.textContent,
              ariaLabel: element.getAttribute('aria-label')
            });
            
            // Report to background script
            this.sendMessage({
              type: 'pdf_detected_in_ui',
              details: {
                text: element.textContent,
                ariaLabel: element.getAttribute('aria-label')
              }
            }).catch(err => {
              logger.error('Error reporting PDF in UI', err);
            });
          }
        }
      });
    } catch (error) {
      logger.error('Error checking for ChatGPT file elements', error);
    }
  }
  
  /**
   * Set up monitoring for drag and drop events
   */
  setupDragAndDropMonitoring() {
    try {
      // Monitor dragover events
      document.addEventListener('dragover', (event) => {
        // Just log for now
        if (this.debugMode) {
          logger.log('Drag event detected');
        }
      });
      
      // Monitor drop events
      document.addEventListener('drop', (event) => {
        if (event.dataTransfer && event.dataTransfer.files) {
          const files = Array.from(event.dataTransfer.files);
          const pdfFiles = files.filter(file => 
            file.type === 'application/pdf' || 
            file.name.toLowerCase().endsWith('.pdf')
          );
          
          if (pdfFiles.length > 0) {
            logger.log('PDF files dropped', {
              count: pdfFiles.length,
              names: pdfFiles.map(f => f.name)
            });
            
            pdfFiles.forEach(file => {
              this.trackUpload(file);
            });
          }
        }
      });
      
      logger.log('Drag and drop monitoring set up');
    } catch (error) {
      logger.error('Error setting up drag and drop monitoring', error);
    }
  }
  
  /**
   * Set up monitoring for clipboard paste events
   */
  setupClipboardMonitoring() {
    try {
      document.addEventListener('paste', (event) => {
        if (event.clipboardData && event.clipboardData.files) {
          const files = Array.from(event.clipboardData.files);
          const pdfFiles = files.filter(file => 
            file.type === 'application/pdf' || 
            file.name.toLowerCase().endsWith('.pdf')
          );
          
          if (pdfFiles.length > 0) {
            logger.log('PDF files pasted from clipboard', {
              count: pdfFiles.length,
              names: pdfFiles.map(f => f.name)
            });
            
            pdfFiles.forEach(file => {
              this.trackUpload(file);
            });
          }
        }
      });
      
      logger.log('Clipboard monitoring set up');
    } catch (error) {
      logger.error('Error setting up clipboard monitoring', error);
    }
  }
  
  /**
   * Monitor for file selection dialog
   * This is a bit hacky but can help detect when a file dialog is opened
   */
  monitorFileSelectionDialog() {
    try {
      // Override the native file input click method
      const originalClick = HTMLInputElement.prototype.click;
      HTMLInputElement.prototype.click = function() {
        if (this.type === 'file') {
          logger.log('File selection dialog opened');
        }
        return originalClick.apply(this, arguments);
      };
      
      logger.log('File selection dialog monitoring set up');
    } catch (error) {
      logger.error('Error setting up file selection dialog monitoring', error);
    }
  }
  
  /**
   * Stop monitoring the page
   */
  stopMonitoring() {
    try {
      if (this.observer) {
        this.observer.disconnect();
      }
      
      // Remove all event listeners
      this.fileInputs.forEach(input => {
        input.removeEventListener('change', this.fileInputChangeHandler);
      });
      
      this.uploadState.monitoring = false;
      logger.log('Stopped monitoring');
    } catch (error) {
      logger.error('Error stopping monitoring', { error: error.message });
    }
  }
  
  /**
   * Scan the page for file input elements
   */
  scanForFileInputs() {
    try {
      const fileInputs = document.querySelectorAll('input[type="file"]');
      
      fileInputs.forEach(input => {
        if (!this.fileInputs.has(input)) {
          // New file input found
          this.fileInputs.add(input);
          
          // Bind change event
          this.fileInputChangeHandler = this.handleFileInputChange.bind(this);
          input.addEventListener('change', this.fileInputChangeHandler);
          
          logger.log('Found new file input', { 
            id: input.id, 
            name: input.name, 
            accept: input.accept 
          });
        }
      });
    } catch (error) {
      logger.error('Error scanning for file inputs', { error: error.message });
    }
  }
  
  /**
   * Set up monitoring for form submissions
   */
  setupFormSubmissionMonitoring() {
    try {
      // Find all forms and add submit listener
      document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', this.handleFormSubmit.bind(this));
      });
      
      // Also monitor all buttons that might trigger uploads
      document.querySelectorAll('button, [role="button"]').forEach(button => {
        button.addEventListener('click', this.handleButtonClick.bind(this));
      });
      
    } catch (error) {
      logger.error('Error setting up form submission monitoring', { error: error.message });
    }
  }
  
  /**
   * Handle file input change event
   * @param {Event} event - Change event
   */
  handleFileInputChange(event) {
    try {
      const input = event.target;
      const files = Array.from(input.files || []);
      
      // Filter for PDF files
      const pdfFiles = files.filter(file => 
        file.type === 'application/pdf' || 
        file.name.toLowerCase().endsWith('.pdf')
      );
      
      if (pdfFiles.length === 0) {
        return;
      }
      
      logger.log('PDF files selected', { 
        count: pdfFiles.length,
        names: pdfFiles.map(f => f.name)
      });
      
      // Track each file
      pdfFiles.forEach(file => {
        this.trackUpload(file);
      });
      
    } catch (error) {
      logger.error('Error handling file input change', { error: error.message });
    }
  }
  
  /**
   * Handle form submission
   * @param {Event} event - Submit event
   */
  handleFormSubmit(event) {
    try {
      const form = event.target;
      
      // Check if form has any file inputs with PDFs
      const fileInputs = form.querySelectorAll('input[type="file"]');
      let hasPDF = false;
      
      fileInputs.forEach(input => {
        const files = Array.from(input.files || []);
        hasPDF = hasPDF || files.some(file => 
          file.type === 'application/pdf' || 
          file.name.toLowerCase().endsWith('.pdf')
        );
      });
      
      if (hasPDF) {
        logger.log('Form submitted with PDF files');
        // Form submission is tracked by the webRequest API
      }
    } catch (error) {
      logger.error('Error handling form submission', { error: error.message });
    }
  }
  
  /**
   * Handle button clicks that might trigger uploads
   * @param {Event} event - Click event
   */
  handleButtonClick(event) {
    try {
      const button = event.target.closest('button, [role="button"]');
      
      // Check if this button might be related to file uploads
      // This is a heuristic and may need refinement
      const isUploadRelated = 
        button.innerText?.toLowerCase().includes('upload') ||
        button.innerText?.toLowerCase().includes('attach') ||
        button.innerText?.toLowerCase().includes('file') ||
        button.innerText?.toLowerCase().includes('send') ||
        button.innerText?.toLowerCase().includes('submit') ||
        button.getAttribute('aria-label')?.toLowerCase().includes('upload') ||
        button.className?.toLowerCase().includes('upload');
      
      if (isUploadRelated) {
        logger.log('Potential upload button clicked', { 
          text: button.innerText,
          ariaLabel: button.getAttribute('aria-label')
        });
        
        // Note: actual upload interception happens via webRequest
      }
    } catch (error) {
      logger.error('Error handling button click', { error: error.message });
    }
  }
  
  /**
   * Track a file upload
   * @param {File} file - File being uploaded
   */
  trackUpload(file) {
    try {
      const fileId = `${file.name}-${file.size}-${Date.now()}`;
      
      this.uploadState.activeUploads.add(fileId);
      
      logger.log('Tracking file upload', { 
        fileId, 
        filename: file.name,
        size: file.size 
      });
      
      // Notify background about potential upcoming upload
      this.sendMessage({
        type: 'pdf_selected',
        fileId,
        filename: file.name,
        size: file.size,
        timestamp: Date.now()
      });
      
      // Try to read the file and send it to the background script
      // This is a backup method in case the webRequest API doesn't catch it
      try {
        const reader = new FileReader();
        reader.onload = () => {
          const base64data = reader.result;
          this.sendMessage({
            type: 'intercepted_pdf',
            requestId: fileId,
            filename: file.name,
            fileSize: file.size,
            fileData: base64data
          }).catch(err => {
            logger.error('Error sending PDF to background', err);
          });
        };
        reader.onerror = (error) => {
          logger.error('Error reading PDF file', error);
        };
        reader.readAsDataURL(file);
      } catch (error) {
        logger.error('Error reading file', error);
      }
      
    } catch (error) {
      logger.error('Error tracking upload', { error: error.message });
    }
  }
  
  /**
   * Handle incoming messages from service worker
   * @param {Object} message - Message object
   * @param {Object} sender - Message sender
   * @param {function} sendResponse - Function to send response
   * @returns {boolean} - Keep channel open for async response
   */
  handleMessage(message, sender, sendResponse) {
    try {
      logger.log('Received message', { type: message.type });
      
      switch (message.type) {
        case 'scan_result':
          this.handleScanResult(message);
          sendResponse({ success: true });
          break;
          
        case 'stop_monitoring':
          this.stopMonitoring();
          sendResponse({ success: true });
          break;
          
        case 'start_monitoring':
          if (!this.uploadState.monitoring) {
            this.startMonitoring();
          }
          sendResponse({ success: true });
          break;
          
        default:
          sendResponse({ success: false, error: 'Unknown message type' });
      }
    } catch (error) {
      logger.error('Error handling message', { error: error.message });
      sendResponse({ success: false, error: error.message });
    }
    
    return true; // Keep message channel open for async response
  }
  
  /**
   * Handle scan result from service worker
   * @param {Object} message - Scan result message
   */
  handleScanResult(message) {
    try {
      const { requestId, result, filename } = message;
      
      logger.log('Received scan result', { 
        requestId, 
        filename,
        hasSecrets: result.secrets 
      });
      
      if (result.secrets) {
        this.showSecretWarning(filename, result);
      }
      
    } catch (error) {
      logger.error('Error handling scan result', { error: error.message });
    }
  }
  
  /**
   * Show warning UI when secrets are detected
   * @param {string} filename - PDF filename
   * @param {Object} result - Scan result
   */
  showSecretWarning(filename, result) {
    try {
      // Create warning element
      const warningEl = document.createElement('div');
      warningEl.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #ff4444;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 9999;
        max-width: 80%;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        display: flex;
        align-items: center;
        gap: 12px;
      `;
      
      // Create icon
      const iconEl = document.createElement('div');
      iconEl.innerHTML = '⚠️';
      iconEl.style.cssText = `
        font-size: 24px;
      `;
      
      // Create content
      const contentEl = document.createElement('div');
      
      // Create title
      const titleEl = document.createElement('div');
      titleEl.textContent = 'Security Risk Detected';
      titleEl.style.cssText = `
        font-weight: bold;
        font-size: 16px;
        margin-bottom: 6px;
      `;
      
      // Create message
      const messageEl = document.createElement('div');
      messageEl.textContent = `The PDF "${filename}" contains potential secrets. Please review before uploading.`;
      messageEl.style.cssText = `
        font-size: 14px;
        margin-bottom: 4px;
      `;
      
      // Create findings list if any
      const findingsEl = document.createElement('div');
      if (result.findings && result.findings.length > 0) {
        findingsEl.textContent = `Found: ${result.findings.map(f => f.type).join(', ')}`;
        findingsEl.style.cssText = `
          font-size: 12px;
          opacity: 0.9;
        `;
      }
      
      // Create close button
      const closeEl = document.createElement('button');
      closeEl.textContent = '×';
      closeEl.style.cssText = `
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0 0 0 10px;
        margin-left: auto;
      `;
      closeEl.addEventListener('click', () => {
        warningEl.remove();
      });
      
      // Assemble UI
      contentEl.appendChild(titleEl);
      contentEl.appendChild(messageEl);
      if (result.findings && result.findings.length > 0) {
        contentEl.appendChild(findingsEl);
      }
      
      warningEl.appendChild(iconEl);
      warningEl.appendChild(contentEl);
      warningEl.appendChild(closeEl);
      
      // Add to page
      document.body.appendChild(warningEl);
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (document.body.contains(warningEl)) {
          warningEl.remove();
        }
      }, 10000);
      
    } catch (error) {
      logger.error('Error showing secret warning', { error: error.message });
    }
  }
  
  /**
   * Send message to service worker
   * @param {Object} message - Message to send
   * @returns {Promise} - Response promise
   */
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      try {
        chrome.runtime.sendMessage(message, response => {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError);
          } else {
            resolve(response);
          }
        });
      } catch (error) {
        reject(error);
      }
    });
  }
}

// Initialize the monitor when the page is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => new PDFMonitor());
} else {
  new PDFMonitor();
} 